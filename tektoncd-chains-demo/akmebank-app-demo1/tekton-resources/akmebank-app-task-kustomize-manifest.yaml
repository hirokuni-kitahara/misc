apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: build-manifest-and-deploy-app
spec:
  params:
  - name: pathToKustomizeBase
    type: string
    description: The build context used by Kustomization
    default: /workspace/kustomize-config-repo/deploy
  - name: deployNamespace
    type: string
    description: The namespace in which app manifest will be deployed
    default: "" # if empty, use namespace metadata if specified in manifest; otherwise just use `default` ns
  - name: builtImageName
    type: string
    description: The image name of built manifest
  resources:
    inputs:
    - name: kustomize-config-repo
      type: git
  steps:
  # --------------------------------------------------
  #  Step 1: build a manifest YAML with kustomize
  # --------------------------------------------------
  - name: kust-build
    # official image `k8s.gcr.io/kustomize/kustomize:v3.8.7` does not contain `git` executable
    image: gcr.io/hk-image-registry/kustomize-git:v3.8.7
    command:
    - /app/kustomize
    args:
    - build
    - --output=/etc/kust-result/manifest.yaml
    - $(params.pathToKustomizeBase)
    volumeMounts:
    - name: kust-result
      mountPath: /etc/kust-result
  # --------------------------------------------------
  #  Step 2: generate provenance.json
  # --------------------------------------------------
  - name: genprov
    image: gcr.io/hk-image-registry/genprov:dev
    imagePullPolicy: Always
    script: |
      #!/bin/bash
      genprov $(params.pathToKustomizeBase) /etc/kust-result/manifest.yaml > /etc/kust-result/provenance.json
    volumeMounts:
    - name: kust-result
      mountPath: /etc/kust-result
  # --------------------------------------------------
  #  Step 3: create a manifest image and sign it with kubectl-sigstore
  # --------------------------------------------------
  - name: k8s-manifest-sign
    image: gcr.io/hk-image-registry/kubectl-sigstore:dev
    command:
    - kubectl-sigstore
    args:
    - sign
    - --filename=/etc/kust-result/manifest.yaml
    - --image=$(params.builtImageName)
    - --key=/secret/cosign.key
    env:
    - name: COSIGN_PASSWORD # this env variable is used by cosign password function
      valueFrom:
        secretKeyRef:
          name: signing-secrets
          key: cosign.password
    volumeMounts:
    - name: kust-result
      mountPath: /etc/kust-result
    - name: signing-secrets
      mountPath: /secret
    - name: gcr-registry-docker-config
      mountPath: /root/.docker/
  # --------------------------------------------------
  #  Step 4: generate attestation.json
  # --------------------------------------------------
  - name: gen-attestation
    image: gcr.io/hk-image-registry/gen-attestation:dev
    imagePullPolicy: Always
    script: |
      #!/bin/bash
      gen-attestation /etc/kust-result/provenance.json /secret/cosign.key $(params.builtImageName) > /etc/kust-result/attestation.json
    env:
    - name: COSIGN_PASSWORD # this env variable is used by cosign password function
      valueFrom:
        secretKeyRef:
          name: signing-secrets
          key: cosign.password
    volumeMounts:
    - name: kust-result
      mountPath: /etc/kust-result
    - name: signing-secrets
      mountPath: /secret
 # --------------------------------------------------
  #  Step 5: upload attestation to rekor
  # --------------------------------------------------
  - name: upload-attestation
    image: gcr.io/hk-image-registry/rekor-cli:dev
    imagePullPolicy: Always
    command: 
    - rekor-cli
    args:
    - upload
    - --artifact=/etc/kust-result/attestation.json
    - --public-key=/secret/cosign.pub
    - --pki-format=x509
    - --type=intoto:0.0.1
    env:
    - name: COSIGN_PASSWORD # this env variable is used by cosign password function
      valueFrom:
        secretKeyRef:
          name: signing-secrets
          key: cosign.password
    volumeMounts:
    - name: kust-result
      mountPath: /etc/kust-result
    - name: signing-secrets
      mountPath: /secret
  # --------------------------------------------------
  #  Step 6: deploy the built manifest
  # --------------------------------------------------
  - name: deploy-app
    image: bitnami/kubectl:1.20.9
    script: |
      #!/bin/bash
      ns_option=$(params.deployNamespace)
      if [[ $ns_option != "" ]]; then
          ns_option="--namespace=${ns_option}"
      fi
      
      # ignore errors just for ignoring `Route` kind error in kind cluster
      kubectl apply $ns_option -f /etc/kust-result/manifest.yaml || true
    volumeMounts:
    - name: kust-result
      mountPath: /etc/kust-result
  volumes:
  - name: kust-result
    emptyDir: {}
  - name: gcr-registry-docker-config
    secret:
      secretName: tektoncd-chains-gcr-secret
      items:
        - key: .dockerconfigjson
          path: config.json
  - name: signing-secrets
    secret:
      secretName: signing-secrets

  
